---
title: Using AI With R
author: Luke Li and David Kane
tutorial:
  id: ai-tutorial-test
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: 'Tutorial for R for Data Science Integrated with AI (test)'
---

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)
library(tidyverse)

library(babynames)

knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 600, 
        tutorial.storage = "local") 
```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```

<!-- DK: Why can't message: false go in the execute block? -->

<!-- DK: Submit a PR to tutorial.helpers which modifies the instructions.qmd at least a bit, like a sentence or two. -->

## Introduction
### 

This tutorial covers [Chapter 12: Logical vectors](https://r4ds.hadley.nz/logicals.html), [Chapter 13: Numbers](https://r4ds.hadley.nz/numbers.html), [Chapter 14: Strings](https://r4ds.hadley.nz/strings.html), [Chapter 15: Regular expressions](https://r4ds.hadley.nz/regexps.html), and [Chapter 16: Factors](https://r4ds.hadley.nz/factors.html), from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. 
You will learn about some of the power of the [**stringr**](https://stringr.tidyverse.org/) package: how to create, combine, and extract strings with the **babynames** package.

<!-- DK: Comment on chapters you are targetting. 12 through 16 -->

## Plotting **babynames**
### 

In this section we are going to focus on generating code to create a graph based on a dataset called `babynames`. The `babynames` is a dataset which contained names used for American babies from 1880 to 2017. If you want to explore related data, checkout [popular baby names](https://www.ssa.gov/oact/babynames/limits.html). We will be using AI to generate the code for us and then we will break down the functions within the code and how they work.


### Exercise 1

Create a Github repo called `plotting-babynames`. Make sure to click the "Add a README file" check box.

Connect the repo to a project on your computer using `File -> New Folder from Git ...`. Make sure to select the "Open in a new window" box. 

You need two Positon windows: this one for running the tutorial and the one you just created for writing your code and interacting with the Console.

Select `File -> New File -> Quarto Document ...`. Provide a title -- `"Baby Names"` -- and an author (you). Render the document and save it as `analysis.qmd`.

Create a `.gitignore` file with `analysis_files` on the first line and then a blank line. Save and push.

In the Console, run:

```         
show_file(".gitignore")
```

If that fails, it is probably because you have not yet loaded `library(tutorial.helpers)` in the Console.

CP/CR.

```{r ai-usage-1}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

Professionals keep their data science work in the cloud because laptops fail.


### Exercise 2

<!-- DK: Do it our way. "Place the cursor . . ." -->

In your QMD, put `library(tidyverse)` in a new code chunk. 
Render the file.

Notice that the file does not look good because the code 
is visible and there are annoying messages. To take care 
of this, add `#| message: false` to remove all the messages 
in this `setup` chunk. Also add the following to the YAML 
header to remove all code echos from the HTML:

```         
execute: 
  echo: false
```

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r ai-usage-2}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

###


### Exercise 3

Place your cursor in the QMD file on the `library(tidyverse)` 
line. Use `Cmd/Ctrl + Enter` to execute that line.

Note that this causes `library(tidyverse)` to be copied down 
to the Console and then executed. 

CP/CR.

```{r ai-usage-3}
question_text(NULL,
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL,
    rows = 3)
```

###



### Exercise 4

<!-- DK: CP/CR makes no sense without `Cmd/Ctrl + Enter`. DONE -->

Load `babynames` in your QMD with the `library()` function. 

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r ai-usage-4}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

###

We load **babynames** into our current QMD so it is accessible to use with the rest of the code in the document.


### Exercise 5

Type `babynames` in the Console to view the dataset. Copy and paste the resulting tibble.

```{r ai-usage-5}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 8)
```

###

Typing out `babynames` is the same as typing out `print(babynames)`. Either way, we can see the same tibble. Look around and try to understand each column.


### Exercise 6

<!-- DK: Tell students to tell the AI not to assign the results yet. -->

<!-- DK: No CP/CR without `Cmd/Ctrl + Enter`. DONE -->

Using your favorite AI, prompt it to generate R code that takes `babynames` and filters the dataset to show all names that have a first name starting with A. Make sure to provide a tibble of **babynames** for the AI to use. If necessary, change the code so that the result of the pipe is not assigned to a variable. Add the code to your QMD in a new chunk. To view the result, place your cursor on the first line of the code and run `Cmd/Ctrl + Enter`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r ai-usage-6}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 4)
```


###

<!-- DK: New pipes only. DONE -->

<!-- DK: No assignment out till the end.  -->

Our code:

```{r, echo=TRUE, eval=TRUE}
babynames |> 
  filter(str_starts(name, "A"))
```


<!-- DK: Knowledge drops focus on material from the relevant chapters. -->

The `filter()` function is used for subsetting data frames by selecting rows that satisfy specific conditions. In this case, it takes rows using `str_starts()`, which essentially takes a column (name), and selects the rows where the string of name starts with A.


### Exercise 7

Now edit the previous code so that the letter is not `"A"`, but rather `"As"`. Place your cursor on a line of the code and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r ai-usage-7}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 4)
```

###

```{r, echo=TRUE, eval=TRUE}
babynames |> 
  filter(str_starts(name, "As"))
```

###

Within the QMD, revert back to the original code with just the `"A"`.

### Exercise 8

Next, prompt AI to continue the pipe to make a subset that shows the total proportion of babies with first names starting with A for each sex, from each year. Add the code to your QMD in the same chunk. Place your cursor on the first line of the code and run `Cmd/Ctrl + Enter`.

If your AI uses `group_by()`, get rid of it and add `.by = c(...)` as an argument within `summarize()`. This is because `group_by()` changes the structure of the resulting tibble in a way which might mess up later steps in the pipe. As a rule, you should not use `group_by()` unless you have a good reason for doing so.

<!-- because `group_by()` changes the structure of the resulting tibble in a way which might mess up later steps in the pipe. As a rule, you should not use `group_by()` unless you have a good reason for doing so. DONE -->

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r ai-usage-8}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 7)
```


###

Our code:

```{r, echo=TRUE}
babynames |> 
  filter(str_starts(name, "A")) |>
  summarize(total_prop = sum(prop), .by = c(year, sex))
```

###

### Exercise 9

You should have one setup code chunk with the `library()`s, and one code chunk with our previous code in your QMD. Within the recent code chunk, add the
option: `#| cache: true`. Assign the result of our pipe to 
`x`. 

`Cmd/Ctrl + Shift + K`. By including `#| cache: true` you cause Quarto to cache the  results of the chunk. The next time you render your QMD, as long as you have not changed the code, Quarto will just load up the saved fitted object.

At the Console, run:

```
tutorial.helpers::show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r ai-usage-9}
question_text(NULL,
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL,
    rows = 8)
```

### 

To confirm, `Cmd/Ctrl + Shift + K` again. It should be quick.

###

```{r, echo=TRUE}
x <- babynames |> 
  filter(str_starts(name, "A")) |>
  summarize(total_prop = sum(prop), .by = c(year, sex))
```


### Exercise 10

<!-- https://pkgs.rstudio.com/learnr/articles/exercises.html -->



Now, type `x` in the Console to view our tibble that we will use. Go to the AI and ask it to generate R code that plots a basic graph showing the proportion of names starting with A over the years for each sex. Mention you want to use the data from `x`, and copy and paste the `x` you ran in the Console with the resulting tibble. You only need the top 3 lines, mainly to include column names.

Within `labs()` edit or add a proper title, subtitle, and caption. If axis labels are appropriate, add them, but if unnecessary, don't bother. Don't assign the code to any variable. Make this in a new code cell. Use `Cmd/Ctrl + Shift + K` to render the QMD.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r ai-usage-10}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 10)
```


###

Our code:

```{r echo=FALSE}
x <- babynames |> 
  filter(str_starts(name, "A")) |>
  summarize(total_prop = sum(prop), .by = c(year, sex))
```

```{r, echo=TRUE}
ggplot(x, aes(x = year, y = total_prop, color = sex)) +
  geom_line(size = 1.2) +
  labs(
    title = "Proportion of Babies with Names Starting with 'A' Over Time",
    subtitle = "Data from 1880 to 2017 shows that the proportion of names starting with 'A' was lowest around the 1950s",
    x = NULL,
    y = NULL,
    caption = "Source: the USA social security administration",
    color = "Sex"
  ) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  theme_minimal()
```

###



### Exercise 11

Now that we have filtered our dataset and created a plot, we need to be on track with the same, correct, code. Replace your code with our code in your QMD.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r ai-usage-11}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 12)
```

###

Knowledge drop


### Exercise 12

Now, we are going to create a new title using string functions. Using AI, ask it to generate code for creating the title of your plot using the function `str_c()` and assign the result to the variable `title1`. The title should stay the same, but they way it is made should be through `str_c()`. Add this code to a the same code cell with the plot, but before the code for the plot. Then, set the argument `title` equal to `title1` within the call to `labs()`.

Place your cursor on the line with the code, and then run `Cmd/Ctrl + Enter`. Then type `title1` in the Console.

CP/CR.

```{r ai-usage-12}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 4)
```


###

Our code:

```{r, echo=TRUE}
title1 <- str_c("Proportion of Babies with Names Starting with ", "'A'", " Over Time")
title1
```

The function `str_c()` takes any number of vectors as arguments and returns a character vector. It essentially combines arguments of the same type into a string. 

###

If you were to not use `str_c()`, double quotes "" or single quotes '' will also create a string. You can add a quote within the string by typing a backslash '\'. To add a backslash, just type another backslash before the backslash you want to add.

### Exercise 13

Once again, place your cursor on the line with the new `str_c()` code and hit `Cmd/Ctrl + Enter`, but don't run it yet. Now edit the code so that within `str_c()`, the strings include a backslash `\` at the start and doublequotes `""` at the end. Remove the variable `title1` it is assigned to and press `Enter` to run the code.

CP/CR.

```{r ai-usage-13}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

###

```{r, echo=TRUE}
str_c("\\Proportion of Babies with Names Starting with ", "'A'", " Over Time\"\"")
```

<!-- LL: why does the function output \\ instead of \, and \"\" instead of ""? -->

Knowledge drop.


### Exercise 14

Now, we are going to do the same, but for a subtitle, and we will use str_glue(). Using AI, ask it to generate code for creating the subtitle of your plot using the the function `str_glue()` and assign the result to the variable `subtitle1`. The subtitle should stay the same, but they way it is made should be through `str_glue()`. Add this code to a the same code cell with the plot, but before the code for the plot. Then, set the argument `subtitle` equal to `subtitle1` within the call to `labs()`.

Place your cursor on the line with the code, and then run `Cmd/Ctrl + Enter`. Then type `subtitle1` in the Console.

CP/CR.

```{r ai-usage-14}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 4)
```


###

Our code:

```{r, echo=TRUE}
subtitle1 <- str_glue("Data from {min(a_summary$year)} to {max(a_summary$year)} shows that the proportion of names starting with 'A' was lowest around the 1950s")
subtitle1
```

The function `str_glue()` is an alternative to `str_c()` that evaluates anything inside {} like it’s outside of the quotes. However, the function converts missing values to the string "NA."

### Exercise 15

Copy and paste the new `str_glue()` code into the Console, but don't run it yet. Now edit the code so that within `str_glue()`, the string includes the `str_c()` line from earlier at the end. Now remove the variable `subtitle1` it is assigned to and press `Enter` to run the code.

CP/CR.

```{r ai-usage-15}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

```{r, echo=TRUE}
str_glue("Data from {min(x$year)} to {max(x$year)} shows that the proportion of names starting with 'A' was lowest around the 1950s {str_c(\"Proportion of Babies with Names Starting with \", \"'A'\", \" Over Time\")}")
```

Knowledge drop (about glue and backslashes)


### Exercise 16

Using the same AI, ask it to generate code for creating an insight of your plot. Here is the prompt we used: using `str_flatten()` on the **babynames** dataset, make another unique insight related to the plot we have already made. Insert your plot code if needed. In a new code chunk after the graph, copy and paste our generated code into your QMD. Render it with `Cmd/Ctrl + K` or run it in the Console to ensure it works.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r ai-usage-16}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 12)
```


###

Our code:

```{r, echo=TRUE}
top_a_1950 <- babynames |>
  filter(year == 1950, str_starts(name, "A")) |>
  arrange(desc(prop)) |>
  slice_head(n = 5)

insight_text <- top_a_1950 |>
  pull(name) |>
  str_flatten(collapse = ", ", last = " and ")

insight <- str_c(
  "In 1950, the most common 'A' names were ", insight_text, 
  ", which drove the total proportion for that year."
)
insight
```

The function `str_flatten()` takes a character vector and combines each element of the vector into a single string. It works well with the function `summarize()`.


<!-- LL: These following 4 exercises need fixing on the AI generated code to make it work properly, and they need 4 more exercises where students edit code -->

### Exercise 17

Using the same AI, ask it to generate code that will find the most common second letters of **babynames** starting with "A" with the function `separate_longer_delim()`. In a new code cell below the previous cells, copy and paste the generated code. Then, place your cursor on any line of the code and press `Cmd/Ctrl + Shift + Enter` to run it in the Console. Then, isolate the part with the relavant function `separate_longer_delim()`, and only run the code up to that section by placing your cursor at the top, and then run the code line by line with `Cmd/Ctrl + Enter` to see what the function changed in the dataset.

CP/CR.

```{r ai-usage-17}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 8)
```


###

Our code:

```{r, echo=TRUE, eval=FALSE}
babynames |>
  filter(str_starts(name, "A")) |>
  separate_longer_delim(name, delim = '') |>
  mutate(pos = row_number(), .by = c(name, year, sex)) |>
  filter(pos == 2) |>
  count(letter = name, sort = TRUE)
```

The function `separate_longer_delim(col, delim)` makes the input data frame longer through increased rows, with the string split up through a specified deliminator as an argument.


### Exercise 18

Using the same AI, ask it to generate similar code that will find the most common second letters of **babynames** starting with "A" with the function `separate_longer_position()`. Using the same code cell from the previous exercise, copy and paste the generated code. Then, place your cursor on any line of the code and press `Cmd/Ctrl + Shift + Enter` to run it in the Console. Then, isolate the part with the relavant function `separate_longer_position()`, and only run the code up to that section by placing your cursor at the top, and then run the code line by line with `Cmd/Ctrl + Enter` to see what the function changed in the dataset.

CP/CR.

```{r ai-usage-18}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 8)
```


###

Our code:

```{r, echo=TRUE, eval=FALSE}
babynames |>
  filter(str_starts(name, "A")) |>
  separate_longer_position(name, width = 1) |>
  mutate(pos = row_number(), .by = c(name, year, sex)) |>
  filter(pos == 2) |>
  count(letter = name, sort = TRUE)
```

The function `separate_longer_position(col, width)` makes the input data frame longer through increased rows, with the string split up with specified widths.


### Exercise 19

Using the same AI, ask it to generate code that will combine two columns using `str_c()`, and then separate them again with `separate_wider_delim()`. Using the same code cell from the previous exercise, copy and paste the generated code. Then, place your cursor on any line of the code and press `Cmd/Ctrl + Shift + Enter` to run it in the Console. For this one, run and print out the change after the first `mutate()`, and then run and print out what happens after the `separate_wider_delim()`. Do this by only running the code up to that section by placing your cursor at the top, and then run the code line by line with `Cmd/Ctrl + Enter` to see what the function changed in the dataset.

CP/CR.

```{r ai-usage-19}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 8)
```


###

Our code:

```{r, echo=TRUE, eval=FALSE}
babynames |>
       filter(str_starts(name, "A")) |> 
       mutate(name_sex = str_c(name, sex, sep = "-")) |> 
       separate_wider_delim(name_sex, delim = "-", names = c("name_clean", "sex_clean")) |> 
       count(sex_clean, name_clean)
```

The function `separate_wider_delim(col, delim, names)` makes the input data frame wider through increased columns, with the string split up with a specified deliminator.


### Exercise 20

Using the same AI, ask it to generate code that will combine two columns using `str_c()`, and then separate them again with `separate_wider_position()`. Using the same code cell from the previous exercise, copy and paste the generated code. Then, place your cursor on any line of the code and press `Cmd/Ctrl + Shift + Enter` to run it in the Console. For this one, run and print out the change after the first `mutate()`, and then run and print out what happens after the `separate_wider_positions()`. Do this by only running the code up to that section by placing your cursor at the top, and then run the code line by line with `Cmd/Ctrl + Enter` to see what the function changed in the dataset.


```{r ai-usage-20}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 8)
```


###

Our code:

```{r, echo=TRUE, eval=FALSE}
babynames |> 
       filter(str_starts(name, "A")) |> 
       mutate(name_sex = str_c(str_pad(name, width = 10, side = "right"), sex)) |> 
       separate_wider_position(name_sex, positions = c(10), names = c("name_clean", "sex_clean")) |> 
       select(name_clean, sex_clean)
```

The function `separate_wider_position(col, widths, names)` makes the input data frame wider through increased columns, with the string split up with a specified widths. Note how because the character length for names varied, we had to pad it with 10 extra characters so we could for sure separate the columns by width.


<!-- LL: Now this section (or the next) could also use an image of a plot, and students ask AI to create code to replicate plot. Students then edit the code and work through the functions we already mentioned. Could be redundant and too long though? -->

## String functions on **babynames**

<!-- LL: This entire section could use another exercise for each existing one where students edit the code. Could be too long though? --> 

###

In this section we are going to focus on generating code to manipulate our dataset called `babynames`. The `babynames` is a data set which contained names used for babies from 1880 to 2017. If you want to explore the data set, checkout [popular baby names](https://www.ssa.gov/oact/babynames/limits.html). 

### Exercise 1

Make a new code cell after the plot, and using AI, ask it to generate code that pipes **babynames** to `count()` with `str_length()` to find the distribution of lengths of US baby names. Make sure that the pipe is not assigned to any variable so it is easier to run. Copy and paste the code into the code cell. Place your cursor on the line with the code, and press `Cmd/Ctrl + Enter` to run the code in the Console.

CP/CR.

```{r string-functions-1}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
``` 


###

Our code:

```{r, echo=TRUE, eval=FALSE}
babynames |>
  count(length = str_length(name), sort = TRUE)
```

The function `str_length()` tells you the number of letters in the string.


### Exercise 2

Next, get code that pipes `babynames` to `mutate()` and use `str_sub()` to find the first and last letter of each name. Make sure that the pipe is not assigned to any variable so it is easier to run. Copy and paste the code into the same code cell. Place your cursor on the line with the code, and press `Cmd/Ctrl + Enter` to run the code in the Console.

CP/CR.

```{r string-functions-2}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
``` 


###

Our code:

```{r, echo=TRUE, eval=FALSE}
babynames |>
  mutate(
    first_letter = str_sub(name, 1, 1),
    last_letter = str_sub(name, -1, -1)
  ) |>
  select(name, first_letter, last_letter)
```

The function `str_sub(string, start, end)` can extract parts of a string. The start and end are the positions where the substring should start and end, and the start and end arguments are inclusive.


### Exercise 3

Next, get code that pipes `babynames` to `filter()` with name and `str_starts()` to find all names beginning with a certain string. Make sure that the pipe is not assigned to any variable so it is easier to run. Copy and paste the code into the same code cell. Place your cursor on the line with the code, and press `Cmd/Ctrl + Enter` to run the code in the Console.

CP/CR.

```{r string-functions-3}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
``` 


###

Our code:

```{r, echo=TRUE, eval=FALSE}
babynames |> filter(str_starts(name, "A"))
```

The function `str_starts()` returns TRUE if each string starts with the given pattern. We have used this function earlier in this tutorial!


### Exercise 4

Next, get code that pipes `babynames` to `filter()` with name and `str_ends()` to find all names ending with a certain string. Make sure that the pipe is not assigned to any variable so it is easier to run. Copy and paste the code into the same code cell. Place your cursor on the line with the code, and press `Cmd/Ctrl + Enter` to run the code in the Console.

CP/CR.

```{r string-functions-4}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
``` 


###

Our code:

```{r, echo=TRUE, eval=FALSE}
babynames |> filter(str_ends(name, "y"))
```

The function `str_ends()` returns TRUE if each string ends with the given pattern.


### Exercise 5

Next, get code that pipes `babynames` to `filter()` with name and `str_detect()` to find all names containing a certain string. Make sure that the pipe is not assigned to any variable so it is easier to run. Copy and paste the code into the same code cell. Place your cursor on the line with the code, and press `Cmd/Ctrl + Enter` to run the code in the Console.

CP/CR.

```{r string-functions-5}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
``` 


###

Our code:

```{r, echo=TRUE, eval=FALSE}
babynames |> filter(str_detect(name, "lex"))
```

The function `str_detect()` returns TRUE if each string contains the given pattern somewhere inside.


### Exercise 6

Next, get code that pipes `babynames` to `mutate()` with `str_to_lower()` and `str_to_upper()` to make new columns in the dataset that convert the string names to different cases. Make sure that the pipe is not assigned to any variable so it is easier to run. Copy and paste the code into the same code cell. Place your cursor on the line with the code, and press `Cmd/Ctrl + Enter` to run the code in the Console.

CP/CR.

```{r string-functions-6}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
``` 


###

Our code:

```{r, echo=TRUE, eval=FALSE}
babynames |>
  mutate(lowercase = str_to_lower(name),
         uppercase = str_to_upper(name))
```

The functions `str_to_lower()` and `str_to_upper()` convert all characters in the string to their respective case.


### Exercise 7

Next, get code that pipes `babynames` to `mutate()` with `str_length()` and then `filter()` to get all names that are X letters long. Make sure that the pipe is not assigned to any variable so it is easier to run. Copy and paste the code into the same code cell. Place your cursor on the line with the code, and press `Cmd/Ctrl + Enter` to run the code in the Console.

CP/CR.

```{r string-functions-7}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
``` 


###

Our code:

```{r, echo=TRUE, eval=FALSE}
babynames |>
  mutate(length = str_length(name)) |>
  filter(length == 10)
```

The function `str_length()` returns the number of characters in each string.


### Exercise 8

Next, get code that pipes `babynames` to `mutate()` with `str_sub()` twice to obtain the first and last letter of each name. Make sure that the pipe is not assigned to any variable so it is easier to run. Copy and paste the code into the same code cell. Place your cursor on the line with the code, and press `Cmd/Ctrl + Enter` to run the code in the Console.

CP/CR.

```{r string-functions-8}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
``` 


###

Our code:

```{r, echo=TRUE, eval=FALSE}
babynames |>
  mutate(first_letter = str_sub(name, 1, 1),
         last_letter = str_sub(name, -1, -1))
```

The function `str_sub()` extracts a substring from a string by position.


### Exercise 9

Next, get code that pipes `babynames` to `filter()` and detect all names with an "a", then pipe it to `mutate()` with `str_replace_all()` to create a new column that replaces all the "a"s with an "x". Make sure that the pipe is not assigned to any variable so it is easier to run. Copy and paste the code into the same code cell. Place your cursor on the line with the code, and press `Cmd/Ctrl + Enter` to run the code in the Console.

CP/CR.

```{r string-functions-9}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
``` 


###

Our code:

```{r, echo=TRUE, eval=FALSE}
babynames |>
  filter(str_detect(name, "a")) |>
  mutate(modified = str_replace_all(name, "ph", "f"))
```

The functions `str_replace()` and `str_replace_all()` replace the first match of a pattern in each string.


### Exercise 10

Next, get code that pipes `babynames` to `mutate()` with `str_count()` to make a new column that counts how many "a"s each name have. Make sure that the pipe is not assigned to any variable so it is easier to run. Copy and paste the code into the same code cell. Place your cursor on the line with the code, and press `Cmd/Ctrl + Enter` to run the code in the Console.

CP/CR.

```{r string-functions-10}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
``` 


###

Our code:

```{r, echo=TRUE, eval=FALSE}
babynames |>
  mutate(num_a = str_count(name, "a"))
```

The function `str_count()` counts the number of times a pattern appears in each string.


### Exercise 11

Next, get code that pipes `babynames` to `distinct()` and then to `mutate()` with `str_sort()` to changes the name column so that it orders the distinct names alphabetically. Make sure that the pipe is not assigned to any variable so it is easier to run. Copy and paste the code into the same code cell. Place your cursor on the line with the code, and press `Cmd/Ctrl + Enter` to run the code in the Console.

CP/CR.

```{r string-functions-11}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
``` 


###

Our code:

```{r, echo=TRUE, eval=FALSE}
babynames |>
  distinct(name) |>
  mutate(name = str_sort(name, locale = "en", decreasing = FALSE))
```

The function `str_sort()` sorts strings alphabetically, optionally by locale or in reverse. Locale refers to the language rules to follow for sorting.


### Exercise 12

Next, get code that pipes `babynames` to `mutate()` with `str_trim()` to create a new column with trimmed names. Make sure that the pipe is not assigned to any variable so it is easier to run. Copy and paste the code into the same code cell. Place your cursor on the line with the code, and press `Cmd/Ctrl + Enter` to run the code in the Console.

CP/CR.

```{r string-functions-12}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
``` 


###

Our code:

```{r, echo=TRUE, eval=FALSE}
babynames |>
  mutate(clean_name = str_trim(name))
```

The function `str_trim()` removes whitespace from the start and/or end of strings.


### Exercise 13

Now that we have all these functions in the same code cell, we can see all of the functions we have learned, and we can run any of them at will with `Cmd/Ctrl + Enter`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r string-functions-13}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 15)
``` 

## Summary
### 

This tutorial covered [Chapter 12: Logical vectors](https://r4ds.hadley.nz/logicals.html), [Chapter 13: Numbers](https://r4ds.hadley.nz/numbers.html), [Chapter 14: Strings](https://r4ds.hadley.nz/strings.html), [Chapter 15: Regular expressions](https://r4ds.hadley.nz/regexps.html), and [Chapter 16: Factors](https://r4ds.hadley.nz/factors.html), from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. 
You learned about some of the power of the [**stringr**](https://stringr.tidyverse.org/) package: how to create, combine, and extract strings with the **babynames** package.

```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```


<!-- DK: List of knowledge drops you plan on moving over from current tutorials. -->
```
### 1

You might be wondering what tibble is, A tibble is a new form of a data frame in R that is part of the tidyverse library, and Tibbles print the data in a more efficient format than a data frame, showing the values of the columns, their datatype, and the size of the dataset.

### 2

The `babynames` is a data set which contained names used for babies from 1880 to 2017. If you want to explore the data set, checkout [popular baby names](https://www.ssa.gov/oact/babynames/limits.html).### 

### 3

To check for `NA` values, use `any()` function with argument `is.na()`, argument of which should be the dataset babynames. 

### 4

We’ve created strings in passing earlier in the book but didn’t discuss the details. Firstly, you can create a string using either single quotes (') or double quotes ("). If you wanted to include single quotes in a string you could put the outer quotes as double quotes.

Now there’s no difference in behavior between the single quotes and double quotes, but in the interests of consistency, the [*Tidyverse*](https://style.tidyverse.org/syntax.html#character-vectors) style guide recommends using `"`, unless the string itself contains double quotes.

### 5

The **stringr** library is a part of the [*Tidyverse*](https://www.tidyverse.org/). We can just load the **tidyverse** library and the **stringr** library will be automatically loaded. 

### 6

The printed representation of a string is not the same as the string itself because the printed representation shows the escapes. To see the raw contents of the string, we use `str_view()`

### 7

There's another way to include quotes in a string. To include a literal single or double quote, you can use the backslash `\` to escape it. For example, `"\""` will return `'"'`. To include a literal backlash in your string, it is pretty simple and all you need to do is have two backslashes in a string to have one literal one. 

### 8

If you find yourself dealing with a complex situation where you have many backslashes and quotes to include, it can become confusing to keep track of them. (This is sometimes called [leaning toothpick syndrome](https://en.wikipedia.org/wiki/Leaning_toothpick_syndrome).)

To solve the issue, we utilized a raw string, which is a specific type of string literal that doesn't interpret any special characters or escape sequences.

Typically, a raw string starts with `r"(, ends with )"`, and allows for any text representation. However, if the string contains )", alternatives like `r"[]"` or `r"{}"` can be used. Furthermore, you can add dashes to ensure unique opening and closing pairs, such as `r"--()--"`, `r"---()---"`, and so on. Raw strings offer flexibility to handle any text without problems.

### 9

Besides `\"`, `\'`, and `\\`, there are a few other special characters that can be useful. The most common ones are `\n` for a new line and `\t` for a tab. If you want to check out a complete list of other special characters, check out in [Quotes](https://rdrr.io/r/base/Quotes.html).
 
### 10

`str_c()` is a function in the `stringr` package in R that combines multiple character vectors into a single character vector. It is similar to the `paste()` function, but it uses `tidyverse` recycling and NA rules. `str_c()` is vectorized, which means it can take multiple arguments and combine them element-wise. 

### 11

If you are mixing many fixed and variable strings with `str_c()`, you’ll notice that you type a lot of `"`s, making it hard to see the overall goal of the code. An alternative approach is provided by the glue package via `str_glue()`. How `str_glue()` works is that if you give it a single string that has a special feature: anything inside `{}` will be evaluated like it’s outside of the quotes. However, `str_glue()` currently converts missing values to the string "NA" unfortunately making it inconsistent with `str_c()`.

### 12

`str_c()` and `str_glue()` are suitable for use with `mutate()` since their output matches the length of their inputs. However, if you need a function that works well with `summarize()` and always returns a single string, `str_flatten()` comes into play. It takes a character vector as input and combines each element of the vector into a single string.

### 13

One variation of `str_flatten()` is `str_flatten_comma()` is a variation designed specifically for flattening with commas. It automatically recognizes if last uses the Oxford comma and handles the special case of 2 elements.

### 14

The `last` argument is an optional string to use in place of the final separator.

### 15

`summarize()` creates a new data frame. It returns one row for each combination of grouping variables; if there are no grouping variables, the output will have a single row summarizing all observations in the input.

### 16

The `.by` arguement is a selection of columns to group by for just this operation, functioning as an alternative to `group_by()`. For details and examples, see `?dplyr_by`.

To review, `mutate()` either changes an existing column or adds a new one. `summarize()` calculates a single value (per group).

### 17

Separating a string into rows tends to be most useful when the number of components varies from row to row. The most common case is requiring `separate_longer_delim()` to split based on a delimiter.

### 18

Just like with `pivot_longer()` and `pivot_wider()`, `_longer` like `separate_longer_delim()` functions make the input data frame longer by creating new rows and `_wider` functions make the input data frame wider by generating new columns.

### 19

If you are wondering what `delim = ","` means, the `delim` argument is used to specify the delimiter character in functions that involve reading or writing delimited data files.

For example, when reading a CSV (Comma-Separated Values) file using the `read_delim()` function from the **readr** package, you can specify `delim = ","` to indicate that the values in the file are separated by commas. 

### 20

As you look at the tibble, notice we can't separate the numbers by commas to make the column longer. That's where `separate_longer_position()` comes into the play.

### 21

If you don't want a column, all we have to do rename to column to be `NA`

### 22

What if you want to separate them by different width in position? `separate_wider_position()` is the function that solves that.

`separate_wider_position()` works a little differently because you typically want to specify the width of each column. So you give it a named integer vector, where the name gives the name of the new column, and the value is the number of characters it occupies. You can omit values from the output by not naming them

### 23

In response to not having the same number of pieces, there are two possible problems, too few or too many pieces, so `separate_wider_delim()` provides two arguments to help: `too_few` and `too_many`.

### 24

When you use the debug mode, you get three extra columns added to the output: `x_ok`, `x_pieces`, and `x_remainder` (if you separate a variable with a different name, you’ll get a different prefix).

`x_pieces` tells us how many pieces were found, compared to the expected 3 (the length of names). `x_remainder` isn’t useful when there are too few pieces, but we’ll see it again shortly

### 25

In other cases, you may want to fill in the missing pieces with `NA`s and move on. That’s the job of `too_few` = `"align_start"` and `too_few` = `"align_end"` which allow you to control where the `NA`s should go.

### 26

You will get an error and get suggestions to use `too_many = "debug"` or `too_many = "drop/merge"`. We will use "debug" to see what being kept and what's being left and after that we will talk about use drop and merge.

When we debug the result, you can see the purpose of `x_remainder`: it shows what was left behind and not inserted into the columns.

As we are already aware by the word `drop`, it has been established that Rstudio will discard the remaining x remainders.

### 27

`str_length()` tells you the number of letters in the string.

`str_length()` not only counts the letters but also the spaces in between the words in a string. If you want to explore more, check out [`str_length()`](https://stringr.tidyverse.org/reference/str_length.html).

### 28

In RStudio, the `==` operator is used to test for equality between two values. It is a comparison operator that returns a logical value of TRUE if the values are equal and FALSE otherwise. 

### 29

You can extract parts of a string using `str_sub(string, start, end)`, where start and end are the positions where the substring should start and end. 

To extract a substring using the `str_sub()` function, specify the following arguments: the first argument should be the variable `y` that we have defined, the second argument should be the starting position (1 in this case), and the third argument should be the ending position (3 in this case).

Looking at results, when using `str_sub()`The start and end arguments are inclusive, so the length of the returned string will be end - start + 1

If you want to look at the end of the string, you can use negative values to count back from the end of the string: -1 is the last character, -2 is the second to last character, etc. Note that `str_sub()` won’t fail if the string is too short: it will just return as much as possible

### 30

If you didnt know, In Python, indexing starts from zero, whereas in RStudio, indexing starts from one, resulting in a slight variation in accessing elements and slicing sequences.
```
