---
title: Databases
author: David Kane and Mann Talati
tutorial:
  id: databases
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: 'Tutorial for Chapter 22: Databases'
---

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)
library(tidyverse)
library(tibble)
library(DBI)
library(dbplyr)
library(RSQLite)
library(RPostgres)
knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 

con <- DBI::dbConnect(duckdb::duckdb(), dbdir = "duckdb")
mpg_sql <- "
  SELECT manufacturer, model, year, displ, class 
  FROM mpg 
  WHERE displ > 1.8
"
mpg_db <- tbl(con, "mpg")
```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```

## Introduction
### 

This tutorial covers [Chapter 22: Databases](https://r4ds.hadley.nz/databases.html) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. You will learn how to use [**DBI**](https://dbi.r-dbi.org/) and the [**dbplyr**](https://dbplyr.tidyverse.org/) to connect to databases and execute SQL.

## Connecting to a database
###

To first start working a database we need to connect to one. You’ll always use `DBI` (database interface) because it provides a set of generic functions that connect to the database, upload data, run SQL queries, etc. You’ll also use a package tailored for the `DBMS` you’re connecting to. This package translates the generic `DBI` commands into the specifics needed for a given `DBMS`. There’s usually one package for each `DBMS`, e.g. `RPostgres` for PostgreSQL and `RMariaDB` for MySQL.

### Exercise 1

Let's run the `library()` on `tidyverse`, `DBI`, and `tibble`.

```{r connecting-to-a-data-1, exercise = TRUE}

```

```{r connecting-to-a-data-1-hint, eval = FALSE}
library(...)
...(DBI)
library(...)
```

###

At the simplest level, you can think about a database as a collection of data frames, called tables in database terminology. Like a data frame, a database table is a collection of named columns, where every value in the column is the same type. Databases are run by database management systems (DBMS’s for short), which come in three basic forms: Client-server, Cloud, and In-process.

### Exercise 2

Set `DBI::dbConnect(duckdb::duckdb())` to the `con` variable.

```{r connecting-to-a-data-2, exercise = TRUE}

```

```{r connecting-to-a-data-2-hint, eval = FALSE}
... <- DBI::dbConnect(duckdb::duckdb())
```

###

`duckdb` is a high-performance database that’s designed very much for the needs of a data scientist. We use it here because it’s very easy to get started with, but it’s also capable of handling gigabytes of data with great speed. 

### Exercise 3

Copy the code from above. Now within the `con` variable, add `dbdir` and set it to "duckdb".

```{r connecting-to-a-data-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r connecting-to-a-data-3-hint, eval = FALSE}
... <- DBI::dbConnect(..., dbdir = "duckdb")
```

###

We want to use `duckdb` for a real data analysis project, so we need to use the `dbdir` argument to make a persistent database and tell `duckdb` where to save it.

### Exercise 4

Let's write the `mpg` data to the database we just created. Use `dbWriteTable()` and within it put the arguments `con`, "mpg", and `ggplot2::mpg`.

```{r connecting-to-a-data-4, exercise = TRUE}

```

```{r connecting-to-a-data-4-hint, eval = FALSE}
dbWriteTable(..., "mpg", ...)
```

###

When we use `dbWriteTable()` we need to supply three arguments: a database connection, the name of the table to create in the database, and a data frame of data.

### Exercise 5

Let's write the `diamonds` data to the database we just created. Use `dbWriteTable()` and within it put the arguments `con`, "diamonds", and `ggplot2::diamonds`.

```{r connecting-to-a-data-5, exercise = TRUE}

```

```{r connecting-to-a-data-5-hint, eval = FALSE}
...(con, ..., ggplot2::diamonds)
```

###

With the `duckdb` database we are using we are using in-process DBMS’s, like `SQLite`, which are run entirely on your computer. They’re great for working with large datasets where you’re the primary user.

### Exercise 6

Run `dbListTables()` on `con`.

```{r connecting-to-a-data-6, exercise = TRUE}

```

```{r connecting-to-a-data-6-hint, eval = FALSE}
dbListTables(...)
```

###

You can check that the data is loaded correctly by using the `dbListTables()` function that lists all tables in the database.

### Exercise 7

Let's use another DBI function: `dbReadTable()`. Start a pipe with `con` and use `dbReadTable()` on "mpg".

```{r connecting-to-a-data-7, exercise = TRUE}

```

```{r connecting-to-a-data-7-hint, eval = FALSE}
con |>
  dbReadTable(...)
```

###

`dbReadTable()` returns a `data.frame`. 

### Exercise 8

Continue the pipe with `as_tibble()` which will return our data in a nice tibble format.

```{r connecting-to-a-data-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r connecting-to-a-data-8-hint, eval = FALSE}
... |>
  as_tibble()
```

###

To convert data into a tibble we use `as_tibble()` which allows it t print nicely.

### Exercise 9

Now let's use `SQL` to select specific variables from the database. Create a `mpg_sql` variable and set it equal to 
"
  SELECT manufacturer, model, year, displ, class 
  FROM mpg 
  WHERE displ > 1.8
"

```{r connecting-to-a-data-9, exercise = TRUE}
```

```{r connecting-to-a-data-9-hint, eval = FALSE}
... <- "
  SELECT manufacturer, model, year, displ, class 
  FROM mpg 
  WHERE displ > 1.8
"
```

###

With the above variable, we want to select 5 specific variables, from the mpg dataset, with only values with `displ` > 1.8.

### Exercise 10

Use `as_tibble()` and within use `dbGetQuery()` and set two arguments con, `mpg_sql` within `dbGetQuery()`.

```{r connecting-to-a-data-10, exercise = TRUE}

```

```{r connecting-to-a-data-10-hint, eval = FALSE}
...(dbGetQuery(con, mpg_sql))
```

###

You can use `dbGetQuery()` to get the results of running a query on the database with `as_tibble()` we get the results in tibble format.

## `dbplyr` basics
###

Now that we’ve connected to a database and loaded up some data, we can start to learn about `dbplyr`. `dbplyr` is a dplyr backend, which means that you keep writing dplyr code but the backend executes it differently. In this, `dbplyr` translates to SQL; other backends include `dtplyr` which translates to `data.table`, and `multidplyr` which executes your code on multiple cores.

### Exercise 1

Create a variable `mpg_db` and set that to `tbl()` on the two arguments: `con` and "mpg".

```{r dbplyr-basics-1, exercise = TRUE}

```

```{r dbplyr-basics-1-hint, eval = FALSE}
mpg_db <- ...(con, "mpg")
```

###

We use `tbl()` To create an object that represents a database table.

### Exercise 2

Start a pipe with `mpg_db` that we created from above and `filter()` all the value with `displ` > 1.8.

```{r dbplyr-basics-2, exercise = TRUE}

```

```{r dbplyr-basics-2-hint, eval = FALSE}
mpg_db |>
  filter(...)
```

###

Similar to using `dbGetQuery()`, we can use the `dbplyr` package to select the same variables from the database that we created. This object is called *lazy*; when you use `dplyr` verbs on it, `dplyr` doesn’t do any work: it just records the sequence of operations that you want to perform and only performs them when needed.

### Exercise 3

Select the `manufacturer`, `model`, `displ`, and `year` through `drv` variables.

```{r dbplyr-basics-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r dbplyr-basics-3-hint, eval = FALSE}
... |>
  select(manufacturer, model, displ, year:drv)
```

###

This represents a database query because it prints the DBMS name at the top, and while it tells you the number of columns, it typically doesn’t know the number of rows. This is because finding the total number of rows usually requires executing the complete query, something we’re trying to avoid.

### Exercise 4

Continue the pipe by adding `show_query()`.

```{r dbplyr-basics-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r dbplyr-basics-4-hint, eval = FALSE}
... |>
  show_query()
```

###

You can see the `SQL` code generated by the dplyr function `show_query()`. If you know `dplyr`, this is a great way to learn `SQL`! Write some `dplyr` code, get `dbplyr` to translate it to `SQL`, and then try to figure out how the two languages match up.

### Exercise 5

Take the pipe from above and remove `show_query()` and instead add `collect()` to the pipe.

```{r dbplyr-basics-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r dbplyr-basics-5-hint, eval = FALSE}
... |>
  collect()
```

###

To get all the data back into R, you call `collect()`. Behind the scenes, this generates the `SQL`, calls `dbGetQuery()` to get the data, then turns the result into a tibble.

## Summary
### 

This tutorial covered [Chapter 22: Databases](https://r4ds.hadley.nz/databases.html) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. You learned how to use [**DBI**](https://dbi.r-dbi.org/) and used [**dbplyr**](https://dbplyr.tidyverse.org/) to connect to databases and execute SQL.

```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```
