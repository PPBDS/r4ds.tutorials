---
title: Missing Values
author: Matthew Ru
tutorial:
  id: missing-values
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: 'Tutorial for Chapter 19: Missing Values'
---

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)
library(tidyverse)
knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 

treatment <- tribble(
  ~person,           ~treatment, ~response,
  "Derrick Whitmore", 1,         7,
  NA,                 2,         10,
  NA,                 3,         NA,
  "Katherine Burke",  1,         4
)
```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```

## Introduction
###

This tutorial covers [Chapter 19: Missing Values](https://r4ds.hadley.nz/missing-values.html) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. The primary focus of this tutorial will be to teach you how to use commands like [`fill()`] to fill in missing values, [`coalesce()`] to replace missing values with another value, and [`na_if()`] to replace certain values with a missing value, [`NA`]. Additionally we will look at functions like [`complete()`] which lets you generate missing values from a set of variables, and how to use [`anti_join()`] for missing values when joining data sets.


## Explicit Missing Values
###

### Exercise 1

Load the **tidyverse** package with the `library()` command.

```{r explicit-missing-val-1, exercise = TRUE}

```

```{r explicit-missing-val-1-hint, eval = FALSE}
library(...)
```

###

The functions for working with missing data mostly come from dplyr and tidyr, which are core members of the tidyverse.

### Exercise 2

Run this code in order to create a tibble called `treatment`.

```{r explicit-missing-val-2, exercise = TRUE}
treatment <- tribble(
  ~person,           ~treatment, ~response,
  "Derrick Whitmore", 1,         7,
  NA,                 2,         10,
  NA,                 3,         NA,
  "Katherine Burke",  1,         4
)
```

###

A common use for missing values is as a data entry convenience. When data is entered by hand, missing values sometimes indicate that the value in the previous row has been repeated (or carried forward).

### Exercise 3

Write `treatment` and hit "Run Code".

```{r explicit-missing-val-3, exercise = TRUE}

```

```{r explicit-missing-val-3-hint, eval = FALSE}
treatment
```

###

Use `glimpse()` or `View()` for alternative ways to view the data.

### Exercise 4

Pipe `treatment` to `fill()` with the argument `response`.

```{r explicit-missing-val-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r explicit-missing-val-4-hint, eval = FALSE}
treatment |>
  ...(response)
```

###

This treatment is sometimes called “last observation carried forward”, or locf for short.

### Exercise 5

Use the same code, but replace `response` with `everything()`. Recall that `everything()` is a function which returns all the variables in a tibble.

```{r explicit-missing-val-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r explicit-missing-val-5-hint, eval = FALSE}
treatment |>
  fill(...)
```

###

You can use the `.direction` argument to fill in missing values that have been generated in more exotic ways.

### Exercise 6

Run this code to assign a vector with a missing value to the variable `x`.

```{r explicit-misisng-values-6, exercise = TRUE}
x <- c(1, 4, 5, 7, NA)
```
###

Many times we will see missing values that actually represent some fixed known value, most commonly 0. 

### Exercise 7

Copy the previous code and use `coalesce()`  from `dplyr` with `x` and `0` as arguments to replace the missing values with `0`

```{r explicit-misisng-values-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r explicit-missing-values-7-hint-1, eval = FALSE}
x <- c(1, 4, 5, 7, NA)
coalesce(x,...)
```

###

As we can see, the `NA` value turned into a `0`.

### Exercise 8

Run this code to assign a vector to the variable `x`.

```{r explicit-misisng-values-8, exercise = TRUE}
x <- c(1, 4, 5, 7, -99)
```

###

At times we will see the opposite issue where some fixed known value actually represents a missing value. 

### Exercise 9

Copy the previous code and use `na_if()` from the `dplyr` package and use `x` and `-99` to replace the `-99` with a missing value.

```{r explicit-misisng-values-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r explicit-missing-values-9-hint-1, eval = FALSE}
x <- c(1, 4, 5, 7, -99)
na_if(x, ...)
```

###

This usually happens when data is generated by some older software that is forced to use a value like `99` or `-999` as a missing value.

### 

Before we continue, there’s one special type of missing value that you’ll encounter from time to time: a `NaN` (pronounced “nan”), or not a number.

### Exercise 10

Multiply the pre-written vector by 10.

```{r explicit-missing-val-10, exercise = TRUE}
 x <- c(NA, NaN)
```

```{r explicit-missing-val-10-hint-1, eval = FALSE}
x <- c(NA, NaN)
x * ...
```

###

As you can see, any mathematical operation on a missing value is still a missing value.

### Exercise 11

Compare the vector x to the number 1.

```{r explicit-missing-val-11, exercise = TRUE}
x <- c(NA, NaN)
```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r explicit-missing-val-11-hint, eval = FALSE}
x <- c(NA, NaN)
x == ...
```

###

Comparing `NaN` with a number will give you `NA` because `NaN` is not a number, making it an invalid comparison.

### Exercise 12

Now, copy the code from the previous exercise and run the command `is.na()` with the argument `x`.

```{r explicit-missing-val-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r explicit-missing-val-12-hint, eval = FALSE}
x <- c(NA, NaN)
x == 1
is.na(...)
```

###

In the rare case you need to distinguish an NA from a NaN, you can use is.nan(x).

### Exercise 13

Divide `0` by `0`.

```{r explicit-missing-val-13, exercise = TRUE}

```


```{r explicit-missing-val-13-hint, eval = FALSE}
.../...
```

###

This mathematical operation yields an indeterminate result which produces `NaN`.

### Exercise 14

Subtract `Inf` from `Inf`.

```{r explicit-missing-val-14, exercise = TRUE}

```


```{r explicit-missing-val-14-hint, eval = FALSE}
...-...
```

###

This is also an indeterminate mathematical operation. 

### Exercise 15

Multiply `0` and `Inf`.

```{r explicit-missing-val-15, exercise = TRUE}

```

```{r explicit-missing-val-15-hint, eval = FALSE}
...*...
```

###

This also produces `NaN` because it is indeterminate.

### Exercise 16

Use `sqrt()` to take the square root of `-1`.

```{r explicit-missing-val-16, exercise = TRUE}

```

```{r explicit-missing-val-16-hint, eval = FALSE}
sqrt(...)
```

###

This yet again produces `NaN` because of its indeterminate result.

## Implicit missing values
###



```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```
