---
title: Data import
author: David Kane
tutorial:
  id: data-import
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: 'Tutorial for Chapter 8: Data import'
---

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)
library(tidyverse)
library(janitor)
knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 


```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```


## Introduction
### 

This tutorial covers [Chapter 8: Data import](https://r4ds.hadley.nz/data-import.html) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. You will learn how to import data into your R project using [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.html) and related functions from the [**readr**](https://readr.tidyverse.org/) package. You will also learn how to write out data to files with functions like [`write_csv()`](https://readr.tidyverse.org/reference/write_delim.html).


## Warm Up
### 

This initial section of the tutorial starts with a slow warm up about reading CSV and other simple text files. The section after this one starts the material from *R for Data Science (2e)*.

### 

"CSV" stands for **c**omma-**s**eparated **v**alues, meaning that the variable names and data values are separated by commas in the file. All the files we will use in this tutorial live in the `data/` directory.

### Exercise 1

Consider the contents of the `test_1.csv` file.

```{r comment = ''}
cat(readLines("data/test_1.csv"), sep = "\n")
```

### 

Write code to read this file into R using `read_csv()`, setting the `file` argument to "data/test_1.csv".

```{r warm-up-1, exercise = TRUE}

```

```{r warm-up-1-hint-1, eval = FALSE}
Use read_csv() to read in a csv file. 
Set the `file` argument to "data/test_1.csv".
```

```{r warm-up-1-hint-2, eval = FALSE}
read_csv(file = "data/test_1.csv")
```

### 

The result when your code is run should look like this:

```{r comment = ''}
read_csv("data/test_1.csv")
```

### 

Working with R interactively is like having a conversation. You say something to R and then R says something back. In this case, you say, "Read this file." R responds with "This data has two rows and three columns." The size of a data set is where the conversation begins.

###

R then provides some information about the columns in the data set. The column specification message is a *suggestion* from R to you to specify the data types for each column of data. R "guesses" a data type until we use the `col_types` argument. 


### Exercise 2

Make the message disappear by setting the `show_col_types` argument to `FALSE`.

```{r warm-up-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r warm-up-2-hint-1, eval = FALSE}
read_csv(file = "data/test_1.csv",
         show_col_types = ...)
```

### 

Hitting Run Code should generate this output:

```{r comment = ''}
read_csv("data/test_1.csv",
         show_col_types = FALSE)
```

### 

It is always better to use the `col_types` argument explicitly in order to ensure that the variable types are what you want them to be. 

R is trying to be helpful by nagging you with that message. It is saying "Don't you want to specify the column types for this data? That would be a good idea!"


### Exercise 3


Consider the contents of the `test_2.csv` file. 

```{r comment = ''}
cat(readLines("data/test_2.csv"), sep = "\n")
```

### 

Write code for skipping the text at the top of `"data/test_2.csv"` by setting the second argument `skip` to the appropriate number.

```{r warm-up-3, exercise = TRUE}

```

```{r warm-up-3-hint-1, eval = FALSE}
In addition to the `file` argument, you will 
need to use the`skip` argument here. Set `skip` 
to 2.
```

```{r warm-up-3-hint-2, eval = FALSE}
read_csv(file = "data/test_2.csv",
          skip = ...)
```

### 

The result when your code is run should look like this:

```{r, comment = ''}
read_csv("data/test_2.csv",
         skip = 2)
```

### 

The argument `skip` is used to skip rows, but to skip columns, you can use the `col_only()` function as the argument to `col_types` in order to read in only the columns which you want. 

### Exercise 4

Consider the contents of the `test_3.csv` file. 

```{r comment = ''}
cat(readLines("data/test_3.csv"), sep = "\n")
```

### 

Write code that will create default names for `"data/test_3.csv"` by setting the `col_names` argument to `FALSE`.

```{r warm-up-4, exercise = TRUE}

```

```{r warm-up-4-hint-1, eval = FALSE}
Use the `col_names argument and set it to FALSE
```

```{r warm-up-4-hint-2, eval = FALSE}
read_csv(file = "data/test_3.csv",
          col_names = ...)
```

### 

The result when your code is run should look like this:

```{r comment = ''}
read_csv("data/test_3.csv",
         col_names = FALSE)
```

### 

The argument `col_names` can also be used to create custom column names. 

### Exercise 5


Consider, again, the contents of the `test_3.csv` file. 

```{r comment = ''}
cat(readLines("data/test_3.csv"), sep = "\n")
```

### 

<!-- Using `col_names`, write code that will name the columns `a`, `b` and `c`.  -->

Set the argument `col_names` to a vector containing the column names `"a"`, `"b"`, and `"c"`.

```{r warm-up-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r warm-up-5-hint-1, eval = FALSE}
Use the `col_names` argument and set it to c("a", "b", "c"). 
```

### 

The result when your code is run should look like this:

```{r comment = ''}
read_csv("data/test_3.csv",
         col_names = (c("a", "b", "c")))
```

### 

`col_names` is not only specific to `read_csv()`, it can be used in other functions such as `read_excel` and `read_delim()`


### Exercise 6

Get rid of the column specification message by setting the `col_types` argument to `cols(a = col_double(), b = col_double(), c = col_double())`.


```{r warm-up-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r warm-up-6-hint-1, eval = FALSE}
read_csv("data/test_3.csv",
         col_names = (c("a", "b", "c")),
         col_types = cols(a = col_double(), 
                        b = col_double(), 
                        c = col_double()))
```

### 

The result when your code is run should look like this:

```{r comment = ''}
read_csv("data/test_3.csv",
         col_names = (c("a", "b", "c")),
         col_types = cols(a = col_double(), 
                        b = col_double(), 
                        c = col_double()))
```

### 

There are many other arguments to `cols`. You can type `?cols` into your console to see all the different arguments!


### Exercise 7

Consider the contents of the `test_5.csv` file. Note the "." for the first value for `b`. In this file, a period indicates a missing value. **This is not always true.** Missing values can be indicated in many different ways. And, sometimes, a period is just a period.

```{r comment = ''}
cat(readLines("data/test_5.csv"), sep = "\n")
```

### 

Write code to recognize the `.` value for `b` in `"data/test_5.csv"` as an NA value by setting the `na` argument to "." in `read_csv`.

```{r warm-up-7, exercise = TRUE}

```

```{r warm-up-7-hint-1, eval = FALSE}
Use the `na` argument and set it to "."
```

```{r warm-up-7-hint-2, eval = FALSE}
read_csv(file = "data/test_5.csv",
         na = ".")
```

### 

The result when your code is run should look like this:

```{r comment = ''}
read_csv("data/test_5.csv",
         na = ".")
```

### 

Before removing `"."`, the `col_type` of Column b was character, but after it became a `double`. One element can change the entire column which can mess up other parts of your code.


### Exercise 8

Consider the contents of the `test_6.csv` file.

```{r comment = ''}
cat(readLines("data/test_6.csv"), sep = "\n")
```

### 

Write code for skipping the text lines within `"data/test_6.csv"` by setting the `comment` to "#".

```{r warm-up-8, exercise = TRUE}

```

```{r warm-up-8-hint-1, eval = FALSE}
Use the `comment` argument and set it to "#".
```

```{r warm-up-8-hint-2, eval = FALSE}
read_csv(file = "data/test_6.csv",
         comment = "...")
```

### 

The result when your code is run should look like this:

```{r comment = ''}
read_csv("data/test_6.csv",
         comment = "#")
```

### 

It doesn't always have to be "#", it can be any character that designates a line as a comment!

### Exercise 9

Consider the contents of the `test_7.csv` file.

```{r comment = ''}
cat(readLines("data/test_7.csv"), sep = "\n")
```

### 

Write code to make sure the column `grade` within `"data/test_7.csv"` appears as an integer variable (`col_integer()`), and `student` as a character variable (`col_character()`).

```{r warm-up-9, exercise = TRUE}

```

```{r warm-up-9-hint-1, eval = FALSE}
Use the col_types argument and set it 
to cols(grade = col_integer(), 
        student = col_character())
```

### 

The result when your code is run should look like this:

```{r comment = ''}
read_csv("data/test_7.csv",
         col_types = cols(grade = col_integer(),
                          student = col_character()))
```

### 

There are many more data types such as `col_logical`, `col_double`, `col_date`, etc.

### Exercise 10

Consider the following tibble `tbl_1`.

```{r}
tbl_1 <- tibble(John = 1 , Aliya = 2, Maxilla = 3)
tbl_1
```

### 

<!-- AG: It seems like tutorial exercises don't store their files in the same place (at least on Windows), so I'm combining the list.files() and write_csv() so that you can see the result. -->

Use `write_csv()` to save this tibble to a file named "tbl_1.csv". Then add `list.files()` after that in order to see the file that you've created.

```{r warm-up-10, exercise = TRUE}

```

```{r warm-up-10-hint-1, eval = FALSE}
The first argument should be the object you want 
to save. The second argument should be the name you 
want the file saved as.
```

```{r warm-up-10-hint-2, eval = FALSE}
write_csv(...)
list.files()
```

### 

Your result should look like include two files: `exercise.Rmd`, which is a file used by the **learnr** package and `tbl_1.csv`, which is the file you created.

There are many arguments to `write_csv()` such as `delim`, `na`, `col_names` and many more to make the written file cleaner.

### Exercise 11

Consider the contents of the `test_bad_names.csv` file.

```{r comment = ''}
cat(readLines("data/test_bad_names.csv"), sep = "\n")
```

### 

Many files will have column names that are not formatted correctly, but **tidyverse** has the `name_repair` argument to fix that. Using the contents of `"data/test_bad_names.csv"`, use the `name_repair` argument and set it to `"universal"` in `read_csv()`

```{r warm-up-11, exercise = TRUE}

```

```{r warm-up-11-hint-1, eval = FALSE}
read_csv(file="data/test_bad_names.csv", name_repair="universal")
```

### 

The result when your code is run should look like this:

```{r comment = ''}
read_csv(file = "data/test_bad_names.csv", name_repair = "universal")
```

### 

The `"universal"` makes sure the columns names are all unique and uses the syntax already built into the `name_repair` command to organize the names. There are other options such as `minimal` and`unique`, try them out!


### Exercise 12

The  [**janitor**](https://garthtarr.github.io/meatR/janitor.html) package is also commonly used for cleaning names. Load in the package below. *Note*: Nothing will be displayed if the code runs correctly.

```{r warm-up-12, exercise = TRUE}

```

```{r warm-up-12-hint-1, eval = FALSE}
library(janitor)
```

### Exercise 13

Now read the file `"data/test_bad_names.csv"` using `read_csv()`. Then pipe it into `clean_names()`, a function from the **janitor** package.

```{r warm-up-13, exercise = TRUE}

```

```{r warm-up-13-hint-1, eval = FALSE}
read_csv(file = "data/test_bad_names.csv") |> 
  clean_names()
```

### 

The result when your code is run should look like this:

```{r comment = ''}
read_csv(file = "data/test_bad_names.csv") |> 
  clean_names()
```

### 

The function `clean_names()` used the syntax within the **janitor** package to clean the names and also makes them unique. This lets you easily access the different columns without running into errors.

### Exercise 14

To make the code cleaner and to reduce the number of pipes, you can set the `name_repair` argument to `janitor::make_clean_names` in `read_csv()`.

```{r warm-up-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r warm-up-14-hint-1, eval = FALSE}
read_csv(file = "data/test_bad_names.csv", 
         name_repair = janitor::make_clean_names)
```

### 

The result when your code is run should look like this:

```{r comment = ''}
read_csv(file = "data/test_bad_names.csv",
         name_repair = janitor::make_clean_names)
```

### 

The **janitor** package has a function called `remove_empty()` to remove empty spaces, `remove_constant()` to remove columns of constant values, and many more. Try them out!



### Exercise 15

CSV files are just one type of **text** file. A text file is any file which includes plain text. The contents of such files are easy to look at in any text editor, or in RStudio.

Consider the contents of the text file `delim_1.txt`:

```{r}
cat(readLines("data/delim_1.txt"), sep = "\n")
```

### 

Write code for reading this file in to R. The values in the file are separated by pipes rather than commas. So, instead of `read_csv()`, you should use `read_delim()`. 

```{r warm-up-15, exercise = TRUE}

```

```{r warm-up-15-hint-1, eval = FALSE}
Set the file argument to "data/delim_1.txt". 
Also use the `delim` argument and set it to "|".
```

### 

The result when your code is run should look like this:

```{r comment = ''}
read_delim("data/delim_1.txt", delim = "|")
```

### 

Note how the spaces and commas are included in the values for `town`. You can't use `read_csv()` here because not all the columns are denoted by commas.

### Exercise 16

Consider the contents of the text file `delim_2.txt`:

```{r}
cat(readLines("data/delim_2.txt"), sep = "\n")
```

### 

Write code for reading this file in to R. Also, use the `col_types` argument to both prevent the col_types message from printing out and to set `population` as an integer.

```{r warm-up-16, exercise = TRUE}

```

```{r warm-up-16-hint-1, eval = FALSE}
Set the `col_types` argument to 
cols(date = col_date(format = ""),
     population = col_integer(),
     town = col_character())
```

```{r warm-up-16-hint-2, eval = FALSE}
read_delim("data/delim_2.txt", 
           delim = "|",
           col_types = cols(date = col_date(format = ""),
                            population = col_integer(),
                            town = col_character()))
```

### 

The result when your code is run should look like this:

```{r comment = ''}
read_delim("data/delim_2.txt", 
           delim = "|",
           col_types = cols(date = col_date(format = ""),
                            population = col_integer(),
                            town = col_character()))
```

## Reading data from a file
### 

Consider this data:

```{r message = FALSE, comment = ''}
read_lines("data/students.csv") |> cat(sep = "\n")
```

## Controlling column types
### 

Before getting to the *R4DS* material, let's do some more warm up exercises.

A lot of the things that **readr** does is done automatically, without us inputting any extra information. All we need to do is type in `read_csv()` and it'll do most of the work for us.

However, **readr** can still mess up, which means that we have to fix the problems manually.


### Exercise 1

```{r controlling-column-t-1-setup}
cat(readLines("data/ex_2.csv"), sep = "\n")
```

For example, there could be problems with how the column types are detected. 

Let's explore the `ex_2.csv` file and fix the parsing failures it causes.  

### 

Read the `data/ex_2.csv` file into R to check if there are any parsing mistakes.

```{r controlling-column-t-1, exercise = TRUE}

```

```{r controlling-column-t-1-hint-1, eval = FALSE}
read_csv("data/ex_2.csv")
```

### 

Notice that R parses column `a` and `b` both as a doubles. However, column `a` should be parsed as an integer and column `b` should be parsed as a date.

### Exercise 2

```{r controlling-column-t-2-setup}
cat(readLines("data/ex_2.csv"), sep = "\n")
```

Begin by using `read_csv()` to read in the file `ex_2.csv`. Then, set the `col_types` argument to `cols()`. Within `cols()`, set `.default` to `col_character()`.

```{r controlling-column-t-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r controlling-column-t-2-hint-1, eval = FALSE}
read_csv(..., 
         col_types = cols(.default = ...)
)
```

### Exercise 3

```{r controlling-column-t-3-setup}
cat(readLines("data/ex_2.csv"), sep = "\n")
```

Pipe the results of `read_csv()` to the function `mutate()`. Within `mutate()` set `a` to `parse_integer(a)`. 

```{r controlling-column-t-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r controlling-column-t-3-hint-1, eval = FALSE}
... |> 
    mutate(a = ...)
```

### 

You can also use `parse_number()` to parse integers, not just `parse_integer()`.

### Exercise 4

```{r controlling-column-t-4-setup}
cat(readLines("data/ex_2.csv"), sep = "\n")
```

Continue your pipe with `mutate()`. Use `parse_date()` to transform `b` to dates. The first argument to `parse_date()` should be `b`. The second argument should be `format`. Set `format` to `"%Y%M%D"`.

```{r controlling-column-t-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r controlling-column-t-4-hint-1, eval = FALSE}
... |> 
  mutate(b = parse_date(b, format="..."))
```

### 

`"%Y%M%D"` tells R to read the number as a date (Y for year, M for month, D for date). 

### Exercise 5

Let's explore one last file `ex_3.csv` that has parsing failures.

```{r controlling-column-t-5-setup}
cat(readLines("data/ex_3.csv"), sep = "\n")
```

 Run `read_csv("data/ex_3.csv")` and examine the parsing failures.

```{r controlling-column-t-5, exercise = TRUE}

```

```{r controlling-column-t-5-hint-1, eval = FALSE}
read_csv("data/ex_3.csv")
```

### 

What are the problems here? First, R parses column `x` as a character, when it is clearly a date. Also, column `z` should be parsed as an integer not a character!

### Exercise 6

```{r controlling-column-t-6-setup}
cat(readLines("data/ex_3.csv"), sep = "\n")
```

Let's first fix column `x`. Pipe the results of `read_csv("data/ex_3.csv")` to the function `mutate()`. Within `mutate()` set `x` to `parse_date(x, "%d %B %Y")`.  

```{r controlling-column-t-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r controlling-column-t-6-hint-1, eval = FALSE}
... |> 
    mutate(x = ...)
```

### 

The `%d` signifies that there's only 1 digit for the day, the `%B` means that we're using the name of the month rather than the number, and the spaces in between represent the spaces in between each value. By customizing our format string, we can easily parse any format of dates without any problems.

Also note that we did not need to use the `.default = col_character()` trick before we used `mutate()`. Why? Because R already read all of the columns as characters to begin with.

### Exercise 7

```{r controlling-column-t-7-setup}
cat(readLines("data/ex_3.csv"), sep = "\n")
```

Continue your pipe with `mutate()`. Within `mutate()` set `z` to `parse_integer(z)`. 

```{r controlling-column-t-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r controlling-column-t-7-hint-1, eval = FALSE}
... |> 
    mutate(z = ...)
```

## Reading data from multiple files
###


Data Scientists deal with a huge number of files loaded with data, so it is important to learn how to clean multiple files at once.

### Exercise 1

Run `list.files("data")` to check what files there are in the `data` folder.

```{r parsing-multiple-fil-1, exercise = TRUE}

```

```{r parsing-multiple-fil-1-hint-1, eval = FALSE}
list.files("data")
```

### 

The function `list.files()` accepts directories, not just names of folders.

### Exercise 2

Set the argument `pattern` to `"similar"` to only look at the files with the names "similar" in them.

```{r parsing-multiple-fil-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r parsing-multiple-fil-2-hint-1, eval = FALSE}
list.files("data", pattern = "similar")
```

### 

The result when your code is run should look like this:

```{r}
list.files("data", pattern = "similar")
```

### 

You can also set `pattern` to ".csv" or ".delim" for those types of files in a folder.

### Exercise 3

To show the exact directory of where the files came from, set the argument `full.names` to `TRUE` in `list.files()`.

```{r parsing-multiple-fil-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r parsing-multiple-fil-3-hint-1, eval = FALSE}
list.files("data", pattern = "similar", full.names = TRUE)
```

### 

The result when your code is run should look like this:

```{r}
list.files("data", pattern = "similar", full.names = TRUE)
```

### Exercise 4

These are the contents of `similar_1.csv`, `similar_2.csv`, `similar_3.csv`, respectively.

```{r}
cat(readLines("data/similar_1.csv"), sep = "\n")
cat(readLines("data/similar_2.csv"), sep = "\n")
cat(readLines("data/similar_3.csv"), sep = "\n")
```

### 

Now let's combine the files by piping the previous code with `read_csv()`!

```{r parsing-multiple-fil-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r parsing-multiple-fil-4-hint-1, eval = FALSE}
list.files("data", pattern = "similar", full.names = TRUE) |> 
  read_csv()
```

### 

Column `b`'s type is `chr` because the "." in `similar_1.csv` makes R think the rest of the column are characters. We will fix that using the `na` argument in `read_csv()`.

### Exercise 5

In `read_csv()`, set the argument `na` to `"."` to get rid of the character in column `b`.

```{r parsing-multiple-fil-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r parsing-multiple-fil-5-hint-1, eval = FALSE}
... |> 
  read_csv(na = ".")
```

### 

The result when your code is run should look like this:

```{r}
list.files("data", pattern = "similar", full.names = TRUE) |> 
  read_csv(na = ".")
```

### 

Because the "." is gone, column `b`'s type is `dbl` now. 

### Exercise 6

Now let's get rid of the annoying "specify column types" message by using the `show_col_types` argument.

```{r parsing-multiple-fil-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r parsing-multiple-fil-6-hint-1, eval = FALSE}
... |> read_csv(na = ".", show_col_types = FALSE)
```

### 

You can use the other arguments of `read_csv()` to further clean your files, such as `col_names`, `col_types`, and `skip`. 

### 

These functions can be used as a stepping stone to filter huge amounts of data, but **Tidyverse** has many interesting functions, explore them!

## RDS files
### 

RDS files store R objects in a file which can be saved on your computer. Then, if you come back to a project, even after restarting R, you can quickly load back the object, without redoing all the code which created it.

### Exercise 1

Consider the following plot.

```{r}
iris |> 
  ggplot(aes(x = Sepal.Length, y = Sepal.Width)) +
  geom_jitter() +
  labs(title = "Sepal Dimensions of Various Species of Iris",
       x = "Sepal Length",
       y = "Sepal Width")
```

### 

We have saved the plot for you to an object named `iris_p`. On the line 8, use `write_rds()` to save this plot to a file named "test_1.rds". *Note*: Nothing will be displayed for you to see.


```{r rds-files-1, exercise = TRUE}
iris_p <- iris |> 
  ggplot(aes(x = Sepal.Length, y = Sepal.Width)) +
  geom_jitter() +
  labs(title = "Sepal Dimensions of Various Species of Iris",
       x = "Sepal Length",
       y = "Sepal Width")

```

```{r rds-files-1-hint-1, eval = FALSE}
The first argument should be the object you want to save. 
The second argument should be the name you want the 
file saved as.
```

```{r rds-files-1-hint-2, eval = FALSE}
write_rds(iris_p, 
          "test_1.rds")
```

### 

The big advantage of creating an rds file is that we can reload the object it contains later, without re-running the code which created it.  

### Exercise 2

```{r rds-files-2-setup}
cat(readLines("data/test_1.rds"), sep = "\n")
```

<!-- Somehow this works unlike what happened in the CSV section, so I'm not touching it. -->

Run `list.files("data")`. You should see your newly created file listed.

```{r rds-files-2, exercise = TRUE}

```

```{r rds-files-2-hint-1, eval = FALSE}
list.files("data")
```

### 

Your result should look like include two files: `exercise.Rmd`, which is a file used by the **learnr** package and `test_1.rds`, which is the file you created.

### 

To find the file in your pc, you can set the argument `include.dirs` to `TRUE` so that `list.files()` can speel out the directories for you.

### Exercise 3

```{r rds-files-3-setup}
cat(readLines("data/test_1.rds"), sep = "\n")
```

Let's now use `read_rds()` to read in the newly created file! Set the `file` argument to "data/test_1.rds".

```{r rds-files-3, exercise = TRUE}

```

```{r rds-files-3-hint-1, eval = FALSE}
read_rds(file = "data/test_1.rds")
```

### 

Plots are just one example of what we can store in and .rds file. We can also store datasets.

### Exercise 4

Consider the following dataset.

```{r}
glimpse(mtcars)
```

### 

Use `write_rds()` to save `mtcars` to a file named `test_2.rds`.

```{r rds-files-4, exercise = TRUE}

```

```{r rds-files-4-hint-1, eval = FALSE}
The first argument should be the object you want to save. 
The second argument should be the name you want the 
file saved as.
```

```{r rds-files-4-hint-2, eval = FALSE}
write_csv(mtcars, "test_2.rds")
```

### 

You are not limited to just one object in an .rds file. You can save multiple!

### Exercise 5

```{r rds-files-5-setup}
cat(readLines("data/test_2.rds"), sep = "\n")
```

<!-- I think RDS files are just different, since this works as well. -->

Run `list.files("data")`. You should see your newly created file listed.

```{r rds-files-5, exercise = TRUE}

```

```{r rds-files-5-hint-1, eval = FALSE}
list.files("data")
```

### 

Your result should look like include two files: `exercise.Rmd`, which is a file used by the **learnr** package and `test_2.rds`, which is the file you created.

### 

You can also use `append` in `write_delim()` to add on data to an existing file.


### Exercise 6

```{r rds-files-6-setup}
cat(readLines("data/test_2.rds"), sep = "\n")
```

Great. Let's now use `read_rds()` to read in the newly created file! Set the `file` argument to "data/test_2.rds".

```{r rds-files-6, exercise = TRUE}

```

```{r rds-files-6-hint-1, eval = FALSE}
read_rds(file = "data/test_2.rds")
```

### 

If you want to also add column names when using `write_csv`, you can set the
`col_names` argument to `TRUE`.

## Summary
### 

This tutorial covered [Chapter 8: Data import](https://r4ds.hadley.nz/data-import.html) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. You learned how to import data into your R project using `[read_csv()](https://readr.tidyverse.org/reference/read_delim.html)` and related functions from the [**readr**](https://readr.tidyverse.org/) package. You also learned how to write out data to files with functions like `[write_csv()](https://readr.tidyverse.org/reference/write_delim.html)`.

The **[janitor](https://sfirke.github.io/janitor/)** package includes a variety of useful functions, especially `[clean_names()](https://sfirke.github.io/janitor/reference/clean_names.html)`.

```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```
